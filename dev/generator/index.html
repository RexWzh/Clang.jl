<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>生成器教程 · Clang.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://rexwzh.github.io/Clang.jl/generator/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Clang.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">介绍</a></li><li class="is-active"><a class="tocitem" href>生成器教程</a><ul class="internal"><li><a class="tocitem" href="#封装-JLL-包的教程"><span>封装 JLL 包的教程</span></a></li><li><a class="tocitem" href="#可变参数函数"><span>可变参数函数</span></a></li></ul></li><li><a class="tocitem" href="../tutorial/">LibClang 教程</a></li><li><a class="tocitem" href="../libclang/">LibClang 封装器的 API 参考</a></li><li><a class="tocitem" href="../api/">Clang 的 API 参考</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>生成器教程</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>生成器教程</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rexwzh/Clang.jl/blob/master/docs/src/generator.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="生成器教程"><a class="docs-heading-anchor" href="#生成器教程">生成器教程</a><a id="生成器教程-1"></a><a class="docs-heading-anchor-permalink" href="#生成器教程" title="Permalink"></a></h1><h2 id="封装-JLL-包的教程"><a class="docs-heading-anchor" href="#封装-JLL-包的教程">封装 JLL 包的教程</a><a id="封装-JLL-包的教程-1"></a><a class="docs-heading-anchor-permalink" href="#封装-JLL-包的教程" title="Permalink"></a></h2><p>在大多数情况下，Clang.jl 的用途是将 Julia 接口导出到由 JLL 包管理的 C 库。 JLL 包封装了一个工件，它提供了一个共享库，可以通过适用于 C 编译器的 <code>ccall</code> 语法和合适的标头进行调用。 Clang.jl 可以将 C 头文件翻译成 Julia 文件，这些文件可以像普通的 Julia 函数和类型一样直接使用。</p><p>包装 JLL 包的一般工作流程如下。</p><ol><li><p>找到与工件目录相关的 C 头文件。</p></li><li><p>找到解析这些标头所需的编译器标志。</p></li><li><p>使用生成器选项创建一个 <code>.toml</code> 文件。</p></li><li><p>用以上三者构建<em>文本(context)</em>并运行。</p></li><li><p>对包装器进行测试和故障排除。</p></li></ol><h3 id="创建默认生成器"><a class="docs-heading-anchor" href="#创建默认生成器">创建默认生成器</a><a id="创建默认生成器-1"></a><a class="docs-heading-anchor-permalink" href="#创建默认生成器" title="Permalink"></a></h3><p>生成器文本由标题列表、编译器标记列表和生成器选项组成。下面的示例创建一个典型的文本并运行生成器。</p><pre><code class="language-julia hljs">using Clang.Generators
using Clang.LibClang.Clang_jll

cd(@__DIR__)

include_dir = normpath(Clang_jll.artifact_dir, &quot;include&quot;)

# wrapper generator options
options = load_options(joinpath(@__DIR__, &quot;generator.toml&quot;))

# add compiler flags, e.g. &quot;-DXXXXXXXXX&quot;
args = get_default_args()
push!(args, &quot;-I$include_dir&quot;)

# only wrap libclang headers in include/clang-c
header_dir = joinpath(include_dir, &quot;clang-c&quot;)
headers = [joinpath(header_dir, header) for header in readdir(header_dir) if endswith(header, &quot;.h&quot;)]

# create context
ctx = create_context(headers, args, options)

# run generator
build!(ctx)</code></pre><p>您还可以使用实验性的 <code>detect_headers</code> 功能自动检测目录中的顶级标头。</p><pre><code class="language-julia hljs">headers = detect_headers(header_dir, args)</code></pre><p>您还需要一个选项文件 <code>generator.toml</code> 来使这个脚本工作，您可以参考 <a href="https://github.com/JuliaInterop/Clang.jl/blob/master/gen/generator.toml">this toml file</a> 作为例子。</p><h3 id="跳过特定符号"><a class="docs-heading-anchor" href="#跳过特定符号">跳过特定符号</a><a id="跳过特定符号-1"></a><a class="docs-heading-anchor-permalink" href="#跳过特定符号" title="Permalink"></a></h3><p>标头可能包含一些未被 Clang.jl 正确处理的符号，或者可能需要手动换行。例如，julia 将 <code>tm</code> 提供为 <code>Libc.TmStruct</code>，因此您可能不想将其映射到新结构。作为解决方法，您可以跳过这些符号。之后，如果需要此符号，您可以将其添加回序言中。 序言由 <code>prologue_file_path</code> 选项指定。</p><ul><li><p>将符号添加到 <code>output_ignorelist</code> 以避免它被包装。</p></li><li><p>如果符号在系统头文件中并导致 Clang.jl 在打印前出错，除了发布问题外，在生成之前写入 <code>@add_def symbol_name</code> 以抑制它被包装。</p></li></ul><h3 id="打印前重写表达式"><a class="docs-heading-anchor" href="#打印前重写表达式">打印前重写表达式</a><a id="打印前重写表达式-1"></a><a class="docs-heading-anchor-permalink" href="#打印前重写表达式" title="Permalink"></a></h3><p>您还可以在打印之前修改生成的包装。Clang.jl 将构建过程分为生成和打印过程。您可以分别运行这两个过程并在打印前重写表达式。</p><pre><code class="language-julia hljs"># build without printing so we can do custom rewriting
build!(ctx, BUILDSTAGE_NO_PRINTING)

# custom rewriter
function rewrite!(e::Expr)
end

function rewrite!(dag::ExprDAG)
    for node in get_nodes(dag)
        for expr in get_exprs(node)
            rewrite!(expr)
        end
    end
end

rewrite!(ctx.dag)

# print
build!(ctx, BUILDSTAGE_PRINTING_ONLY)</code></pre><h3 id="多平台配置"><a class="docs-heading-anchor" href="#多平台配置">多平台配置</a><a id="多平台配置-1"></a><a class="docs-heading-anchor-permalink" href="#多平台配置" title="Permalink"></a></h3><p>一些标头可能包含与系统相关的符号，例如 <code>long</code> 或 <code>char</code>，或者与系统无关的符号可能会解析为与系统相关的符号。例如，<code>time_t</code> 通常只是一个 64 位无符号整数，但实现可能有条件地将其实现为 <code>long</code> 或 <code>long long</code>，这是不可移植的。您可以跳过这些符号并手动将它们添加回来，如 <a href="#跳过特定符号">跳过特定符号</a>。如果差异太大而无法手动修复，您可以为每个平台生成包装器，如 <a href="https://github.com/Gnimuc/LibClang.jl/blob/v0.61.0/gen/generator.jl">LibClang.jl</a>.</p><h2 id="可变参数函数"><a class="docs-heading-anchor" href="#可变参数函数">可变参数函数</a><a id="可变参数函数-1"></a><a class="docs-heading-anchor-permalink" href="#可变参数函数" title="Permalink"></a></h2><p>借助 <code>@ccall</code> 宏，可以从 Julia 调用可变参数的 C 函数。例如，<code>@ccall printf(&quot;%d\n&quot;::Cstring; 123::Cint::Cint</code> 可用于调用 C 函数 <code>printf</code>。请注意，分号 <code>;</code> 之后的那些参数是可变参数。</p><p>如果选项的 <code>codegen</code> 部分中的 <code>wrap_variadic_function</code> 设置为 <code>true</code>，则 <code>Clang.jl</code> 将为可变 C 函数生成包装器。例如，<code>printf</code> 将被包装如下。</p><pre><code class="language-julia hljs">@generated function printf(fmt, va_list...)
        :(@ccall(libexample.printf(fmt::Ptr{Cchar}; $(to_c_type_pairs(va_list)...))::Cint))
    end</code></pre><p>它可以像普通的 Julia 函数一样调用而无需指定类型：<code>LibExample.printf(&quot;%d\n&quot;, 123)</code>。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>尽管支持可变参数函数，但不能在 Julia 中使用 C 类型 <code>va_list</code>。</p></div></div><h3 id="类型对应"><a class="docs-heading-anchor" href="#类型对应">类型对应</a><a id="类型对应-1"></a><a class="docs-heading-anchor-permalink" href="#类型对应" title="Permalink"></a></h3><p>然而，可变参数 C 函数必须使用正确的参数类型调用，下面列出了最有用的部分。</p><p>| C型 | ccall 签名 | Julia 类型 | |––––––––––––––––––|–––––– –––––––––––––––––––|––––– –––––––––––––––| | 整数和浮点数 | 同类型 | 同类型 | | 结构体 <code>T</code> | 具有相同布局的具体 Julia 结构 <code>T</code> | <code>T</code> | | 指针 (<code>T*</code>) | <code>Ref{T}</code> 或 <code>Ptr{T}</code> | <code>Ref{T}</code> 或 <code>Ptr{T}</code> 或任何数组类型 | | 字符串 (<code>char*</code>) | <code>Cstring</code> 或 <code>Ptr{Cchar}</code> | <code>字符串</code> |</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Ref</code> 在 Julia 中不是具体类型而是抽象类型。比如 <code>Ref(1)</code> 就是 <code>Base.RefValue(1)</code>，不能直接传给 C。</p></div></div><p>从表中可以看出，如果要将字符串或数组传递给 C，则需要将类型注释为 <code>Ptr{T}</code> 或 <code>Ref{T}</code>（或 <code>Cstring</code>）。否则将传递表示 <code>String</code> 或 <code>Array</code> 类型而不是缓冲区本身的结构。有两种方法可以传递这些类型的参数：</p><p>直接使用 @ccall 宏：<code>@ccall printf(&quot;%s\n&quot;; &quot;hello&quot;::Cstring)::Cint</code>。您还可以为常见用例创建封装器。</p><ul><li>重载 <code>to_c_type</code> 以将 Julia 类型映射到正确的 ccall 签名类型：将 <code>to_c_type(::Type{String}) = Cstring</code> 添加到序言（可以通过在选项中设置 <code>prologue_file_path</code> 来添加序言）。然后所有类型为 <code>String</code> 的参数都将被注释为 <code>Cstring</code>。</li></ul><p>上面的类型对应可以通过在序言中包含以下几行来实现。</p><pre><code class="language-julia hljs">to_c_type(::Type{&lt;:AbstractString}) = Cstring # or Ptr{Cchar}
to_c_type(t::Type{&lt;:Union{AbstractArray,Ref}}) = Ptr{eltype(t)}</code></pre><p>有关调用 C 函数的完整教程，请参阅 Julia 手册中的 <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Calling-C-and-Fortran-Code">调用 C 和 Fortran 代码</a>。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« 介绍</a><a class="docs-footer-nextpage" href="../tutorial/">LibClang 教程 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 February 2023 01:15">Thursday 9 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
